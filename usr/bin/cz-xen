#!/usr/bin/perl
#
# Copyright 2012-2014 Board of Trustees, Leland Stanford Jr. University
# Copyright 2015-2021 Bill MacAllister <bill@ca-zephyr.org>
#
# Script to manage xen virtual hosts

use AppConfig qw(:argcount :expand);
use Carp;
use File::Basename;
use File::Copy;
use Getopt::Long;
use IPC::Run qw( run timeout );
use Net::DNS;
use Net::Domain qw( hostfqdn );
use Net::Netmask;
use Net::Remctl;
use Pod::Usage;
use CZ::Xentools;
use strict;

my $opt_arch = 'amd64';
my $opt_confirm;
my $opt_cpu = 2;
my $opt_debug;
my $opt_disk;
my $opt_diskid = '-disk';
my $opt_dist;
my $opt_force;
my $opt_gateway;
my $opt_help;
my $opt_ip = 'dhcp';
my $opt_key;
my $opt_manual;
my $opt_mask;
my $opt_memory;
my $opt_method;
my $opt_moptions;
my $opt_noudev;
my $opt_password = 'vmPassWord';
my $opt_pygrub;
my $opt_role;
my $opt_running;
my $opt_setup = '/etc/cz-xen-setup.conf';
my $opt_swapsize;
my $opt_template;
my $opt_verbose;

my $CONF;
my $DEBUG_TIME = time;

##############################################################################
# Subroutines
##############################################################################

# ----------------------------------------------------------------------
# output debugging information

sub dbg {
    (my $tmp) = @_;
    my $now     = time;
    my $elapsed = $now - $DEBUG_TIME;
    print {*STDOUT} "$now ($elapsed) $tmp \n"
      or croak("Problem writing debugging to STDOUT\n");
    $DEBUG_TIME = $now;
    return;
}

# ----------------------------------------------------------------------
# Validate an ip address

sub validate_ip {
    my ($ip) = @_;
    my $err = 0;
    if ($ip !~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/xms) {
        warn "Invalid IP Address: $ip\n";
        my $err = 1;
    }
    return $err;
}

# ----------------------------------------------------------------------
# Validate a list of ip addresses

sub validate_ip_list {
    my ($ip_csv) = @_;
    my @ip_list = split(/,/xms, $ip_csv);
    my $err_cnt;
    foreach my $ip (@ip_list) {
        $err_cnt += validate_ip($ip);
    }
    if ($err_cnt > 0) {
        pod2usage(-verbose => 0);
    }
    return;
}

# ----------------------------------------------------------------------
# Take an address/cidr and return the corresponding netmask

sub net_size2mask {
    my ($ip_cidr) = @_;
    my $block = Net::Netmask->new($ip_cidr);
    return $block->mask();
}

# ----------------------------------------------------------------------
# Run a shell command line

sub run_cmd {
    my ($timeout, @cmd) = @_;

    my $in;
    my $out;
    my $err;
    my $cmd_line = 'Executing: ' . join(' ', @cmd);
    msg("$cmd_line\n");
    cz_syslog($cmd_line);
    eval { run(\@cmd, \$in, \$out, \$err, timeout($timeout)); };
    if ($@) {
        if ($err) {
            $err .= "\n";
        }
        $err .= "ERROR executing:$cmd_line\n";
        $err .= $@;
        croak "$err\n";
    }
    if ($opt_debug) {
        if ($out) {
            msg("$out\n");
        }
        if ($err) {
            msg("INFO: $err\n");
        }
    }
    return $out;
}

# ----------------------------------------------------------------------
# Lookup IP address

sub lookup_ip {
    my ($host) = @_;
    my $ip;
    my $res   = Net::DNS::Resolver->new;
    my $query = $res->search($host);
    if ($query) {
        foreach my $rr ($query->answer) {
            if ($rr->type eq 'A') {
                $ip = $rr->address;
                last;
            }
        }
    }
    return $ip;
}

# ----------------------------------------------------------------------
# Validate the xen configuration file

sub validate_xen_conf {
    my ($vhost) = @_;
    my $conf_file = "/etc/xen/${vhost}.cfg";
    if (!-e $conf_file) {
        msg("ERROR: $vhost not a Xen host.\n");
        exit 1;
    }
    return $conf_file;
}

# ----------------------------------------------------------------------
# Read the setup configuration file if it exists

sub read_conf {
    if ($opt_debug) {
        dbg("reading setup file $opt_setup");
    }
    $CONF = AppConfig->new({});
    $CONF->define(
        'command_path',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/bin:/sbin:/usr/bin:/usr/sbin'
        }
    );
    $CONF->define('copy_file', { ARGCOUNT => ARGCOUNT_LIST });
    $CONF->define(
        'default_disk',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '40Gb'
        }
    );
    $CONF->define(
        'default_dist',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 'bionic'
        }
    );
    $CONF->define('default_domain', { ARGCOUNT => ARGCOUNT_ONE });
    $CONF->define(
        'default_memory',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '4Gb'
        }
    );
    $CONF->define('default_role', { ARGCOUNT => ARGCOUNT_ONE });
    $CONF->define(
        'default_template',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/etc/xen-tools/xm.tmpl'
        }
    );
    $CONF->define('dir', { ARGCOUNT => ARGCOUNT_LIST });
    $CONF->define(
        'keytab_directory',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/etc/xen-tools/keytabs'
        }
    );
    $CONF->define(
        'krb_keytab',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/etc/krb5.keytab'
        }
    );
    $CONF->define(
        'krb_principal',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 'host/' . hostfqdn()
        }
    );
    $CONF->define(
        'krb_realm',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 'DOMAIN.TOP'
        }
    );
    $CONF->define(
        'role_dir',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/etc/xen-tools/role.d'
        }
    );
    $CONF->define(
        'tgt_file',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/tmp/cz-xen-backup-' . $$ . '.tgt'
        }
    );
    $CONF->define(
        'timeout_action',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '2'
        }
    );
    $CONF->define(
        'timeout_delete',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '5'
        }
    );
    $CONF->define(
        'timeout_list',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '2'
        }
    );
    $CONF->define(
        'timeout_mount',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '2'
        }
    );
    $CONF->define(
        'timeout_new',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '30'
        }
    );
    $CONF->define(
        'toolset',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/usr/sbin/xl'
        }
    );
    $CONF->define(
        'xen_cfg_dir',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/etc/xen'
        }
    );
    $CONF->define('xen_server', { ARGCOUNT => ARGCOUNT_LIST });

    # Read the configuration file if there is one
    if (-e $opt_setup) {
        $CONF->file($opt_setup);
    }

    # Command line overrides
    if ($opt_disk) {
        $CONF->default_disk($opt_disk);
    }
    if ($opt_dist) {
        $CONF->default_dist($opt_dist);
    }
    if ($opt_memory) {
        $CONF->default_memory($opt_memory);
    }
    if ($opt_role) {
        $CONF->default_role($opt_role);
    }
    if ($opt_template) {
        $CONF->default_template($opt_template);
    }

    return;
}

# ----------------------------------------------------------------------
# Display example configuration file

sub example_conf {

    msg("# ----------------------------------------------------\n");
    msg("# Example su xen configuration file $opt_setup\n");
    msg("#\n");
    msg("# ----------------------------------------------------\n");
    msg("#\n");
    msg("# Set the PATH\n");
    msg("command_path = /bin:/sbin:/usr/bin:/usr/sbin\n");
    msg("#\n");
    msg("# Copy files from dom0 to domu.\n");
    msg("# (The script always checks for a host keytab.)\n");
    msg("copy_file = /some/dir/file1 to /some/dir/file1\n");
    msg("copy_file = /other/dir/file2 to /some/dir/file3\n");
    msg("#\n");
    msg("# Default disk size\n");
    msg("default_disk = 40Gb\n");
    msg("#\n");
    msg("# Default distribution\n");
    msg("default_dist = bionic\n");
    msg("#\n");
    msg("# Default domain\n");
    msg("default_domain = ca-zephyr.org\n");
    msg("#\n");
    msg("# Default memory allocation\n");
    msg("default_memory = 4Gb\n");
    msg("#\n");
    msg("# Default xen-tools role\n");
    msg("default_role = cz-focal\n");
    msg("#\n");
    msg("# Default xen-tools template for xen cfg generation\n");
    msg("default_template = /etc/xen-tools/xm.tmpl\n");
    msg("#\n");
    msg("# Directory that hosts keytabs for virtual machines.\n");
    msg("keytab_directory = /etc/xen-tools/keytabs\n");
    msg("#\n");
    msg("# Kerberos credentials used for requesting services of other\n");
    msg("# other xen servers.\n");
    msg("krb_keytab = /etc/krb5.keytab\n");
    msg("krb_principal = host/thishost.domain.top\n");
    msg("krb_realm = DOMAIN.TOP\n");
    msg("tgt_file = /tmp/cz-xen.tgt\n");
    msg("#\n");
    msg("# The xen-tools role directroy\n");
    msg("role_dir = /etc/xen-tools/role.d\n");
    msg("#\n");
    msg("# The timeout unit of measure is minutes\n");
    msg("timeout_action = 2\n");
    msg("timeout_delete = 5\n");
    msg("timeout_list = 2\n");
    msg("timeout_mount = 2\n");
    msg("timeout_new = 30\n");
    msg("#\n");
    msg("# Toolset to use to manage domu systems.  This should be\n");
    msg("# changed only if the location of xl changes\n");
    msg("toolset = /usr/sbin/xl\n");
    msg("#\n");
    msg("# Xen configuration directory\n");
    msg("xen_cfg_dir = /etc/xen\n");
    msg("#\n");
    msg("# Servers in the xen pool.  This used by the find command.\n");
    msg("xen_server = server1.domain.top\n");
    msg("xen_server = server2.domain.top\n");
    msg("xen_server = server3.domain.top\n");
    msg("#\n");

    return;
}

# ----------------------------------------------------------------------
# Take an array contain elements like '/in/path to /out/path' and
# return a hash of the form $hash{'/in/path'} = '/out/path'.

sub get_install_paths {
    my ($paths_ref) = @_;

    my %paths = ();
    for my $ps (@{$paths_ref}) {
        $ps =~ s/\s+to\s+/ /xms;
        $ps =~ s/^\s+//xms;
        $ps =~ s/\s+$//xms;
        $ps =~ s/\s\s+/ /xmsg;
        my ($in, $out) = split /\s/, $ps;
        if (!$out) {
            msg("Skipping copy line: $ps\n");
        } else {
            $paths{$in} = $out;
        }
    }
    return %paths;
}

# ----------------------------------------------------------------------
# Access the console of a domU

sub console {
    my ($vhost) = @_;
    my @cmd = ($CONF->toolset(), 'console', $vhost);
    msg(join(' ', @cmd) . "\n");
    exec @cmd;
    return;
}

# ----------------------------------------------------------------------
# Copy files from the dom0 systm to the VM

sub copy_dom0_files {
    my ($vhost, $file_list_ref) = @_;

    my %file_list      = %{$file_list_ref};
    my $vm_mount_point = mount_vm_disk($vhost);
    $vm_mount_point =~ s{/$}{}xms;

    for my $to (sort keys %file_list) {
        my $from = $vm_mount_point . '/' . $file_list{$to};
        msg("Copying $from to $to\n");
        copy($from, $to)
          or carp("WARN: problem copying $from to $to\n");
    }
    if ($vm_mount_point) {
        umount_vm_disk($vhost);
    }

    return;
}

##############################################################################
# Script Actions
##############################################################################

# ----------------------------------------------------------------------
# Maintain auto action for VMs

sub auto_maint {
    my ($action, $this_host) = @_;

    my %cfg_file = ();
    opendir(my $dir, $CONF->xen_cfg_dir())
      or croak('ERROR: problem opening ' . $CONF->xen_cfg_dir() . "\n");
    while (my $file = readdir($dir)) {
        if ($file =~ /[.]cfg$/xms) {
            my $a_host = $file;
            $a_host =~ s/[.]cfg$//xms;
            $cfg_file{ $CONF->role_dir() . "/${file}" } = $a_host;
        }
    }
    closedir($dir);

    # Set a default action
    if (!$action) {
        $action    = 'show';
        $this_host = 'ALL';
    }

    # show auto status for all hosts
    if ($action eq 'show') {
        msg("AUTOBOOT Status\n");
        msg("---------------\n");
        for my $f (sort keys %cfg_file) {
            my $h = $cfg_file{$f};
            my $a = $CONF->xen_cfg_dir() . "/auto/${h}.cfg";
            if (-e $a) {
                msg("AUTOBOOT $h\n");
            } else {
                msg("no autoboot link for $h\n");
            }
        }
        return;
    }

    if (!$this_host) {
        msg("ERROR: an fqdn or ALL must be specified\n");
        exit 1;
    }

    # get a list of files to operate on
    my @file_list = ();
    if ($this_host eq 'ALL') {
        for my $f (sort keys %cfg_file) {
            push @file_list, $f;
        }
    } else {
        my $this_file = $CONF->xen_cfg_dir() . "/${this_host}.cfg";
        if (!-e $this_file) {
            msg("ERROR: invalid host ($this_host)\n");
            exit 1;
        } else {
            push @file_list, $this_file;
        }
    }

    # Perform the operation
    for my $f (sort @file_list) {
        my $h              = $cfg_file{$f};
        my $this_auto_file = $CONF->xen_cfg_dir() . "/auto/${h}.cfg";
        if ($action eq 'on') {
            my $a_dir = $CONF->xen_cfg_dir() . '/auto';
            if (!-e $a_dir) {
                mkdir $a_dir, 0755
                  or croak("ERROR: problem creating $a_dir\n");
            }
            if (-e $this_auto_file) {
                msg("INFO: $h already set to AUTOBOOT\n");
            } else {
                msg("Setting $h to AUTOBOOT\n");
                link $f, $this_auto_file
                  or croak("ERROR: problem link to $f\n");
            }
        } elsif ($action eq 'off') {
            if (-e $this_auto_file) {
                unlink $this_auto_file
                  or croak("ERROR: problem removing link $this_auto_file\n");
            } else {
                msg("INFO: $h not set to autoboot\n");
            }
        } else {
            msg("ERROR: invalid action $action\n");
            exit 1;
        }
    }

    return;
}

# ----------------------------------------------------------------------
# Create a virtual machine

sub create_vm {
    my ($vhost) = @_;

    # Require both hostname
    if (!$vhost) {
        warn "Insufficient arguments\n";
        pod2usage(-verbose => 0);
    }

    # Get an ip address
    my $vip = $opt_ip;
    if ($opt_ip eq 'dns') {
        $vip = lookup_ip($vhost);
        if (!$vip) {
            msg("ERROR:IP Address lookup failed, specify address with --ip\n");
            pod2usage(-verbose => 0);
        }
    }

    # Make sure it looks like an ip address
    if ($opt_ip ne 'dhcp') {
        validate_ip($vip);
    }

    # validate size specifications
    my $z;
    if ($CONF->default_disk() !~ /^\d+(?: Gb | Mb )/xmsi) {
        warn "Invalid value for disk size.  Units are Mb or Gb.\n";
        pod2usage(-verbose => 0);
    }
    $z = $CONF->default_disk();
    $z =~ tr/gmB/GMb/;
    $CONF->default_disk($z);
    if ($CONF->default_memory() !~ /^\d+(?: Gb | Mb )/xmsi) {
        warn "Invalid value for memory size.  Units are Mb or Gb.\n";
        pod2usage(-verbose => 0);
    }
    $z = $CONF->default_memory();
    $z =~ tr/gmB/GMb/;
    $CONF->default_memory($z);
    if ($opt_swapsize) {
        if ($opt_swapsize !~ /^\d+(?: Gb | Mb )/xmsi) {
            warn "Invalid value for swap size.  Units are Mb or Gb.\n";
            pod2usage(-verbose => 0);
        }
        $opt_swapsize =~ tr/gmB/GMb/;
    }

    # validate install method
    if ($opt_method && $opt_method !~ /^(?: rinse | debootstrap)$/xms) {
        warn "Invalid method\n";
        pod2usage(-verbose => 0);
    }

    # validate arch
    if ($opt_arch && $opt_arch !~ /^(?:i386|amd64)$/xms) {
        warn "Invalid arch\n";
        pod2usage(-verbose => 0);
    }

    # validate the distribution
    my $dist_dir;
    if (-e '/usr/lib/xen-tools') {
        $dist_dir = '/usr/lib/xen-tools';
    } elsif (-e '/usr/share/xen-tools') {
        $dist_dir = '/usr/share/xen-tools';
    } else {
        warn "No OS distributions available\n";
        pod2usage(-verbose => 0);
    }
    if (!-e "${dist_dir}/" . $CONF->default_dist() . '.d') {
        warn 'Invalid distribution ' . $CONF->default_dist() . "\n";
        pod2usage(-verbose => 0);
    }

    # set the default method
    if (!$opt_method && $CONF->default_dist() =~ /^(?: fedora | centos )/xms) {
        $opt_method = 'rinse';
    }

    # Get the keytab for the host if requested
    if ($opt_key) {
        get_keytab($vhost);
    }

    # generate the vm
    my @cmd = ('/usr/bin/xen-create-image');
    push @cmd, "--hostname=${vhost}";
    push @cmd, '--memory=' . $CONF->default_memory;
    push @cmd, '--genpass=1';
    push @cmd, '--size=' . $CONF->default_disk();
    push @cmd, '--template=' . $CONF->default_template();
    if ($opt_ip eq 'dhcp') {
        push @cmd, "--dhcp";
    } else {
        push @cmd, "--ip=${vip}";
        if ($opt_gateway) {
            push @cmd, "--gateway=$opt_gateway";
        }
        if ($opt_mask) {
            push @cmd, "--mask=$opt_mask";
        }
    }
    if ($opt_cpu) {
        push @cmd, "--vcpus=$opt_cpu";
    }
    if ($opt_pygrub) {
        push @cmd, '--pygrub';
    }
    if ($opt_swapsize) {
        push @cmd, "--swap=${opt_swapsize}";
    } else {
        push @cmd, '--noswap';
    }
    push @cmd, '--role=' . $CONF->default_role();
    push @cmd, '--dist=' . $CONF->default_dist();
    push @cmd, "--arch=$opt_arch";
    if ($opt_method) {
        push @cmd, "--install-method=${opt_method}";
    }
    msg("Be patient this takes time ...\n");
    my $create_timeout = 60 * $CONF->timeout_new();
    my $out            = run_cmd($create_timeout, @cmd);

    msg($out);

    # Look for files to copy from dom0 to domu
    my %file_list   = ();
    my $principal   = "host/$vhost";
    my $keytab_file = $CONF->keytab_directory . '/' . $vhost . '.keytab';
    if (-e $keytab_file) {
        $file_list{'/etc/krb5.keytab'} = $keytab_file;
    }
    for my $copy_request (sort(@{ $CONF->copy_file })) {
        if ($copy_request =~ /(\S+) \s+ to \s+ (\S+)/xms) {
            my $from = $1;
            my $to   = $2;
            $file_list{$to} = $from;
        } else {
            msg("WARN: bad format.  Skipping copy_file = $copy_request\n");
        }
    }
    if (%file_list) {
        copy_dom0_files($vhost, \%file_list);
    }

    return;
}

# ----------------------------------------------------------------------
# Delete a virtual machine

sub delete_vm {
    my ($vhost) = @_;

    if (!$opt_confirm) {
        msg("INFO: The VM be deleted from the disk.\n");
        msg("INFO: This is NOT reversable.\n");
        msg("\n");
        msg("INFO: If you mean to shut the VM down use destroy instead.\n");
        msg("\n");
        msg("INFO: To delete the VM complete add the --confirm switch to \n");
        msg("INFO: the command line.\n");

        die("ERROR: Refusing to delete VM without --confirm\n");
    }

    # Make sure we know what to delete
    validate_xen_conf($vhost);

    # set timeout for command execution
    my $cmd_timeout = 60 * $CONF->timeout_delete();

    # destroy it first if it is running
    my @cmd   = ($CONF->toolset(), 'list');
    my $out   = run_cmd($cmd_timeout, @cmd);
    my @lines = split /\n/, $out;
    for my $s (@lines) {
        if ($s =~ /^$vhost\s/xms) {
            @cmd = ($CONF->toolset(), 'destroy', $vhost);
            $out = run_cmd($cmd_timeout, @cmd);
            msg($out);
            last;
        }
    }

    # delete the vm
    my @cmd = ('/usr/bin/xen-delete-image', ${vhost});
    my $out = run_cmd($cmd_timeout, @cmd);
    msg($out);

    if ($@) {
        msg('ERROR: Problem executing:' . join(q{ }, @cmd));
        croak($@);
    }

    return;
}

# ----------------------------------------------------------------------
# This is a dispatching routine that calls either the search for a
# running vm or search for any vm routines.

sub find_vm {
    my @regex_list = @_;

    if (!@{ $CONF->xen_server }) {
        die "ERROR: no xen_server's defined in the configuration file\n";
    }

    if ($opt_debug) {
        dbg('Using principal: ' . $CONF->krb_principal);
        dbg('Keytab file ' . $CONF->krb_keytab);
    }
    create_ticket_cache($CONF);
    if ($opt_running) {
        find_running(@regex_list);
    } else {
        find_any_vm(@regex_list);
    }
    destroy_ticket_cache($CONF);

    return;
}

# ----------------------------------------------------------------------
# Find running VMs or display all of them

sub find_running {
    my @regex_list = @_;

    my $cnt = 1;
    my @report;
    msg('Searching ' . scalar(@{ $CONF->xen_server }) . ' hosts: ');
    for my $xhost (sort(@{ $CONF->xen_server })) {
        my $host_found = 0;
        print("$cnt ");
        $cnt++;

        my @cl = ();
        push @cl, 'xen', 'show';
        if ($opt_debug) {
            dbg('Executing: remctl ' . $xhost . ' ' . join(' ', @cl));
        }
        my $remctl = Net::Remctl->new;
        $remctl->set_timeout(30);
        if (!$remctl->open($xhost)) {
            msg("\nERROR: cannot connect to $xhost\n");
            msg("INFO: skipping\n");
            next;
        }
        if (!$remctl->command(@cl)) {
            msg("\nERROR: cannot send command: " . $remctl->error . "\n");
            msg("INFO: skipping\n");
            next;
        }
        my $output;
        my $output_data;
        do {
            $output = $remctl->output;
            if ($output->type eq 'output') {
                if ($output->stream == 1) {
                    $output_data .= $output->data;
                } elsif ($output->stream == 2) {
                    msg("\nERROR: " . $output->data . "\n");
                }
            } elsif ($output->type eq 'error') {
                msg("\nERROR:" . $output->error . "\n");
            } elsif ($output->type eq 'status') {
                if ($opt_debug) {
                    dbg('output status:' . $output->status);
                }
            } else {
                die "Unknown output token from library: ", $output->type, "\n";
            }
        } while ($output->type eq 'output');
        if ($output_data) {
            my @host_list = split "\n", $output_data;
            for my $h (@host_list) {
                if ($h =~ m/^(\S+)\s+(\d+)\s+(\d+)/xms) {
                    my $vhost = $1;
                    my $id    = $2;
                    my $mem   = $3;
                    for my $r (@regex_list) {
                        if ($vhost =~ /$r/xms) {
                            if (!$host_found) {
                                push @report, "$xhost\n";
                                $host_found = 1;
                            }
                            push @report, sprintf("  %4s %s\n", $vhost, $id);
                        }
                    }
                }
            }
        }
    }

    msg("\n");
    if (@report) {
        msg("\n");
        for my $z (@report) {
            msg($z);
        }
    } else {
        msg("INFO: No matching hosts found\n");
    }
    return;
}

# ----------------------------------------------------------------------
# Find any or all VMs

sub find_any_vm {
    my @regex_list = @_;

    my $cnt = 1;
    my @report;
    msg('Searching ' . scalar(@{ $CONF->xen_server }) . ' hosts: ');
    for my $xhost (@{ $CONF->xen_server }) {
        my $host_found = 0;
        print("$cnt ");
        $cnt++;

        my @cl = ();
        push @cl, 'xen', 'list';
        if ($opt_debug) {
            dbg('Executing: remctl ' . $xhost . ' ' . join(' ', @cl));
        }
        my $remctl = Net::Remctl->new;
        $remctl->set_timeout(30);
        if (!$remctl->open($xhost)) {
            msg("\nERROR: cannot connect to $xhost\n");
            msg("INFO: skipping\n");
            next;
        }
        if (!$remctl->command(@cl)) {
            msg("\nERROR: cannot send command: " . $remctl->error . "\n");
            msg("INFO: skipping\n");
            next;
        }
        my $output;
        my $output_data;
        do {
            $output = $remctl->output;
            if ($output->type eq 'output') {
                if ($output->stream == 1) {
                    $output_data .= $output->data;
                } elsif ($output->stream == 2) {
                    msg("\nERROR: " . $output->data . "\n");
                }
            } elsif ($output->type eq 'error') {
                msg("\nERROR: " . $output->error . "\n");
            } elsif ($output->type eq 'status') {
                if ($opt_debug) {
                    dbg('output status:' . $output->status);
                }
            } else {
                die "Unknown output token from library: ", $output->type, "\n";
            }
        } while ($output->type eq 'output');
        if ($output_data) {
            my @host_list = split "\n", $output_data;
            for my $l (@host_list) {
                if ($l =~ /^Name:\s+(\S+)/xms) {
                    my $this_name = $1;
                    for my $r (@regex_list) {
                        if ($this_name =~ /$r/xms) {
                            if (!$host_found) {
                                push @report, "$xhost\n";
                                $host_found = 1;
                            }
                            push @report, "    $this_name\n";
                        }
                    }
                }
            }
        }
    }

    msg("\n");
    if (@report) {
        msg("\n");
        for my $z (@report) {
            msg($z);
        }
    } else {
        msg("INFO: No matching hosts found\n");
    }
    return;
}

# ----------------------------------------------------------------------
# Download the host keytab

sub get_keytab {
    my ($vhost) = @_;

    if (!$vhost) {
        die "ERROR: name of virtual host missing\n";
    }

    if ($opt_debug) {
        dbg('Using principal: ' . $CONF->krb_principal);
        dbg('Keytab file ' . $CONF->krb_keytab);
    }
    create_ticket_cache($CONF);

    my @cl          = ();
    my $principal   = "host/$vhost";
    my $keytab_file = $CONF->keytab_directory . '/' . $vhost . '.keytab';

    my @cl = ('wallet', 'get', '-f', $keytab_file, 'keytab', $principal);
    if ($opt_debug) {
        dbg('Executing: ' . join(' ', @cl));
    }
    run_cmd(60, @cl);

    destroy_ticket_cache($CONF);

    return;
}

# ----------------------------------------------------------------------
# List current distributions

sub list_dists {

    # List files in the /usr/lib/xen-tools directory
    msg("Installable distributions:\n");
    my $dir;
    if (-e '/usr/lib/xen-tools') {
        $dir = '/usr/lib/xen-tools';
    } elsif (-e '/usr/share/xen-tools') {
        $dir = '/usr/share/xen-tools';
    } else {
        die("ERROR: can't find any distributions");
    }
    my %dir_list = ();
    opendir(my $df, $dir)
      or croak("ERROR: problem opening directory $dir\n");
    while (my $file = readdir($df)) {
        next if $file eq 'common.sh';
        next if $file =~ /^[.]{1,2}$/xms;
        $file =~ s/[.]d$//xms;
        $dir_list{$file} = 1;
    }
    closedir $df
      or croak("ERROR: problem closing directory $dir\n");
    for my $d (sort keys %dir_list) {
        msg("$d\n");
    }
    return;
}

# ----------------------------------------------------------------------
# List LVM volume group sizes

sub list_freedisk_space {

    my @cmd         = ('/sbin/vgdisplay');
    my $cmd_timeout = 60 * $CONF->timeout_list();
    my $out         = run_cmd($cmd_timeout, @cmd);
    my @out_lines   = split /\n/, $out;
    for my $z (@out_lines) {
        if ($z =~ /Name/) {
            msg("\n$z\n");
        } elsif ($z =~ /Size/) {
            msg("$z\n");
        }
    }
    return;
}

# ----------------------------------------------------------------------
# Display free memory using xl

sub list_freemem {

    my @cmd         = ('/usr/sbin/xl', 'info');
    my $cmd_timeout = 60 * $CONF->timeout_list();
    my $out         = run_cmd($cmd_timeout, @cmd);
    my @lines       = split /\n/, $out;
    msg("Memory units are megabytes.\n");
    msg("\n");
    for my $l (@lines) {
        if ($l =~ /memory/) {
            msg("$l\n");
        }
    }
    return;
}

# ----------------------------------------------------------------------
# List dom0 information

sub list_info {

    my @cmd         = ('/usr/sbin/xl', 'info');
    my $cmd_timeout = 60 * $CONF->timeout_list();
    my $out         = run_cmd($cmd_timeout, @cmd);
    my @out_lines   = split /\n/, $out;
    for my $z (@out_lines) {
        msg("$z\n");
    }
    return;
}

# ----------------------------------------------------------------------
# List xen-tools rules excluding the README file

sub list_roles {

    # List files in the /usr/lib/xen-tools/role.d directory
    msg('Roles found in ' . $CONF->role_dir() . "\n");
    my $df;
    my %dir_list = ();
    opendir($df, $CONF->role_dir());
    while (my $file = readdir($df)) {
        next if $file eq 'README';
        next if $file =~ /^[.]{1,2}$/xms;
        $file =~ s/[.]d$//xms;
        $dir_list{$file} = 1;
    }
    for my $d (sort keys %dir_list) {
        msg("$d\n");
    }
    return;
}

# ----------------------------------------------------------------------
# print a role file back to STDOUT

sub show_role {
    my ($role) = @_;

    if (!$role || $role eq 'ALL') {
        opendir(my $dir, $CONF->role_dir())
          or croak('ERROR: problem opening ' . $CONF->role_dir() . "\n");
        while (my $file = readdir($dir)) {
            if ($file !~ /^[.]/xms) {
                msg("$file\n");
            }
        }
        closedir($dir);
        return;
    }

    my $role_file = $CONF->role_dir() . "/$role";
    if (-e $role_file) {
        my $rf;
        open $rf, '<', $role_file or croak("Cannot open $role_file\n");
        while (<$rf>) {
            my $line = $_;
            msg($_);
        }
        close $rf or msg("WARN: Problem closing $role_file");
    } else {
        msg("ERROR: $role_file not found");
    }
    return;
}

# ----------------------------------------------------------------------
# List the disks associated with a VM

sub list_vm_disks {
    my ($vhost) = @_;

    # Require both hostname
    if (!$vhost) {
        msg("WARN: Insufficient arguments\n");
        pod2usage(-verbose => 0);
    }

    # Open the configuration and read until we find the device
    # name for the xen disk.
    my $ch;
    my $vm_conf = validate_xen_conf($vhost);
    open($ch, '<', $vm_conf);
    my $vm_device;
    my $disk_block = 0;
    my $disk_found = 0;
    msg("Disk list for $vhost:\n");

    while (<$ch>) {
        my $in_line = $_;
        if (!$disk_block) {
            if ($in_line =~ /^disk\s+=\s+\[/xms) {
                $disk_block = 1;
            }
            next;
        }
        if ($in_line =~ /\]/xms) {
            last;
        }
        if ($in_line =~ m{\s*phy:(/dev/[\w\d\-\_]+/)([\w\d\-\.]+),}xms) {
            $disk_found = 1;
            my $vm_device      = $1;
            my $vm_disk        = $2;
            my $vm_mount_point = "/mnt/$vm_disk";
            if (-e $vm_mount_point) {
                msg("  vm_disk  MOUNTED\n");
            } else {
                msg("  $vm_disk\n");
            }
        }
    }
    if (!$disk_found) {
        msg("No Disks found\n");
    }
    return;
}

# ----------------------------------------------------------------------
# List virtual machines

sub list_vms {
    my @cmd         = ('/usr/bin/xen-list-images');
    my $cmd_timeout = 60 * $CONF->timeout_list();
    my $out         = run_cmd($cmd_timeout, @cmd);
    if ($opt_verbose) {
        msg($out);
    } else {
        my @lines = split '\n', $out;
        for my $l (@lines) {
            if ($l =~ /^Name:\s+ (.*)/xms) {
                msg("$l\n");
            }
        }
    }
    return;
}

# ----------------------------------------------------------------------
# Mount the vm's disk

sub mount_vm_disk {
    my ($vhost) = @_;

    # Require both hostname
    if (!$vhost) {
        msg("WARN: Insufficient arguments\n");
        pod2usage(-verbose => 0);
    }

    # Open the configuration and read until we find the device
    # name for the xen disk.
    my $ch;
    my $vm_conf = validate_xen_conf($vhost);
    open($ch, '<', $vm_conf);
    my $vm_device;
    my $disk_block = 0;
    my $disk_name  = $vhost . $opt_diskid;
    while (<$ch>) {
        my $in_line = $_;
        if (!$disk_block) {
            if ($in_line =~ /^disk\s+=\s+\[/xms) {
                $disk_block = 1;
            }
            next;
        }
        if ($in_line =~ /\]/xms) {
            last;
        }
        if ($in_line =~ m{\s*phy:(/dev/[\w\d\_\-]+/$disk_name),}xms) {
            $vm_device = $1;
            last;
        }
    }
    if (!$vm_device) {
        msg("ERROR: disk $vm_device not found in $vm_conf\n");
        exit 1;
    }
    if (!-e $vm_device) {
        msg("ERROR: disk device $vm_device does not exist\n");
        exit 1;
    }

    # Create the mount point
    my $vm_mount_point = "/mnt/$disk_name";
    if (!-e $vm_mount_point) {
        mkdir $vm_mount_point;
    }

    # Mount the disk
    my @cmd;
    push @cmd, 'mount', $vm_device, $vm_mount_point;
    if ($opt_moptions) {
        push @cmd, '-o', $opt_moptions;
    }
    my $cmd_timeout = 60 * $CONF->timeout_mount();
    my $out         = run_cmd($cmd_timeout, @cmd);
    msg($out);

    return $vm_mount_point;
}

# ----------------------------------------------------------------------
# Dismount the vm's disk

sub umount_vm_disk {
    my ($vhost) = @_;

    # Require both hostname
    if (!$vhost) {
        msg("WARN: Insufficient arguments\n");
        pod2usage(-verbose => 0);
    }

    # The mount point
    my $vm_mount_point = "/mnt/${vhost}${opt_diskid}";
    if (!-e $vm_mount_point) {
        msg("ERROR: $vm_mount_point not mounted\n");
        exit 1;
    }

    # Dismount the disk
    my @cmd            = ('umount', $vm_mount_point);
    my $umount_timeout = 60 * $CONF->timeout_mount();
    my $out            = run_cmd($umount_timeout, @cmd);
    msg($out);
    rmdir($vm_mount_point)
      or croak("ERROR: problem deleting mount point $vm_mount_point\n");

    return;
}

# ----------------------------------------------------------------------
# Perform an xm action
sub xtool_action {
    my ($action) = @_;

    my @cmd         = ($CONF->toolset(), $action);
    my $cmd_timeout = 60 * $CONF->timeout_action;
    my $out         = run_cmd($cmd_timeout, @cmd);
    msg($out);
    return;
}

# ----------------------------------------------------------------------
sub xtool_host_action {
    my ($vhost, $action) = @_;

    # Require hostname
    if (!$vhost) {
        warn "Hostname required\n";
        pod2usage(-verbose => 0);
    }

    # All destroys to be forced when the configuration file is missing.
    if ($opt_force && $action eq 'destroy') {
        msg("INFO: Force destroy'ing $vhost");
    } else {
        validate_xen_conf($vhost);
    }

    # Perform the requested action
    my @cmd         = ($CONF->toolset(), $action, $vhost);
    my $cmd_timeout = 60 * $CONF->timeout_action();
    my $out         = run_cmd($cmd_timeout, @cmd);
    msg($out);
    return;
}

# ----------------------------------------------------------------------
sub xtool_conf_action {
    my ($vhost, $action) = @_;
    # Require hostname
    if (!$vhost) {
        warn "Hostname required\n";
        pod2usage(-verbose => 0);
    }
    my $conf_file = validate_xen_conf($vhost);

    my @cmd         = ($CONF->toolset(), 'create', $conf_file);
    my $cmd_timeout = 60 * $CONF->timeout_action();
    my $out         = run_cmd($cmd_timeout, @cmd);
    msg($out);
    return;
}

##############################################################################
# Main Routine
##############################################################################

GetOptions(
    'arch=s'     => \$opt_arch,
    'confirm'    => \$opt_confirm,
    'cpu=i'      => \$opt_cpu,
    'debug'      => \$opt_debug,
    'disk=s'     => \$opt_disk,
    'diskid=s'   => \$opt_diskid,
    'dist=s'     => \$opt_dist,
    'force'      => \$opt_force,
    'gateway=s'  => \$opt_gateway,
    'help'       => \$opt_help,
    'ip=s'       => \$opt_ip,
    'key!'       => \$opt_key,
    'manual'     => \$opt_manual,
    'mask=s'     => \$opt_mask,
    'memory=s'   => \$opt_memory,
    'method=s'   => \$opt_method,
    'moptions=s' => \$opt_moptions,
    'password=s' => \$opt_password,
    'pygrub'     => \$opt_pygrub,
    'role=s'     => \$opt_role,
    'running'    => \$opt_running,
    'setup=s'    => \$opt_setup,
    'swapsize=s' => \$opt_swapsize,
    'template=s' => \$opt_template,
    'verbose'    => \$opt_verbose
) or die("ERROR: invalid command line arguments\n");

# Flush output immediately
$| = 1;

# help the poor souls out
pod2usage(-verbose => 0) if $opt_help;
pod2usage(-verbose => 2) if $opt_manual;
pod2usage(-verbose => 0) if !$ARGV[0] || $ARGV[0] eq 'help';
pod2usage(-verbose => 2) if !$ARGV[0] || $ARGV[0] eq 'manual';

my $action = $ARGV[0];

# read the configuration file and setup syslog
read_conf();
cz_init_tools(basename($0), $opt_debug);

# Set the default for a role
if ($action eq 'new') {
    my $role_file = $CONF->role_dir() . '/' . $CONF->default_role();
    if (!-e $role_file) {
        msg("WARN: $role_file is not present.\n");
    }
}

# Defaults for networking setup if static address
if ($opt_ip ne 'dhcp') {
    if ($opt_gateway) {
        validate_ip($opt_gateway);
    }
    if ($opt_ip =~ /([\d\.]+)\/(\d)+/xms) {
        my $ip   = $1;
        my $cidr = $2;
        $opt_ip   = $ip;
        $opt_mask = net_size2mask("$ip/$cidr");
    }
    if ($opt_mask) {
        validate_ip($opt_mask);
    }
    if ($opt_ip ne 'dns') {
        validate_ip($opt_ip);
    }
}

my $vhost;
my $role;
my $auto;
my $auto_host;

if ($ARGV[1]) {
    if ($action eq 'showrole') {
        $role = $ARGV[1];
    } elsif ($action eq 'auto') {
        if (scalar(@ARGV) > 3) {
            warn("Too many arguments on the command line\n");
            exit(1);
        }
        $auto      = $ARGV[1];
        $auto_host = $ARGV[2];
    } else {
        $vhost = $ARGV[1];
        if ($action ne 'find' && scalar(@ARGV) > 2) {
            warn("Too many arguments on the command line\n");
            exit(1);
        }
    }
}

# Set a default domain if we need to
if ($vhost && $vhost !~ /[.]/xms) {
    if ($CONF->default_domain()) {
        $vhost .= $CONF->default_domain;
    } else {
        warn("Please specify an FQDN for the vhost\n");
        exit(1);
    }
}

# Set the environment so and scripts that are called have the
# correct environment
$ENV{PATH} = $CONF->command_path();

# Do something
if    ($action eq 'auto')      { auto_maint($auto, $auto_host); }
elsif ($action eq 'boot')      { xtool_conf_action($vhost, 'create'); }
elsif ($action eq 'console')   { console($vhost); }
elsif ($action eq 'delete')    { delete_vm($vhost); }
elsif ($action eq 'destroy')   { xtool_host_action($vhost, $action); }
elsif ($action eq 'example')   { example_conf(); }
elsif ($action eq 'find')      { find_vm(@ARGV); }
elsif ($action eq 'freedisk')  { list_freedisk_space(); }
elsif ($action eq 'freemem')   { list_freemem(); }
elsif ($action eq 'info')      { list_info(); }
elsif ($action eq 'key')       { get_keytab($vhost); }
elsif ($action eq 'list')      { list_vms(); }
elsif ($action eq 'listdisks') { list_vm_disks($vhost); }
elsif ($action eq 'listdists') { list_dists(); }
elsif ($action eq 'listroles') { list_roles(); }
elsif ($action eq 'mount')     { mount_vm_disk($vhost); }
elsif ($action eq 'new')       { create_vm($vhost); }
elsif ($action eq 'reboot')    { xtool_host_action($vhost, $action); }
elsif ($action eq 'show')      { xtool_action('list'); }
elsif ($action eq 'showrole')  { show_role($role); }
elsif ($action eq 'shutdown')  { xtool_host_action($vhost, $action); }
elsif ($action eq 'umount')    { umount_vm_disk($vhost); }
else {
    warn "Unknown action ($action)\n";
    pod2usage(-verbose => 0);
}

exit;

__END__

=head1 NAME

cz-xen

=head1 SYNOPSIS

     cz-xen auto [on|off|show] [<vm-name>|ALL]
     cz-xen boot <vm-name>
     cz-xen console <vm-name>
     cz-xen delete <vm-name>
     cz-xen destroy <vm-name> [--force]
     cz-xen example
     cz-xen find [<fragment> <fragment> ...]
     cz-xen freedisk
     cz-xen freemem
     cz-xen help
     cz-xen list
     cz-xen listdists
     cz-xen listdisks <vm-name>
     cz-xen listroles
     cz-xen key <vm-name>
     cz-xen manual
     cz-xen mount <vm-name> [<mount-options>]
     cz-xen new <vm-name>
     cz-xen reboot <vm-name>
     cz-xen show
     cz-xen showrole <rolename>
     cz-xen shutdown <vm-name>
     cz-xen umount <vm-name>

=head1 DESCRIPTION

Manage xen virtual machines.  The name of the machine and the ip-address
are required.

=head1 ACTIONS

=over 4

=item auto [show|on|off] [<vm name>|ALL]

The auto action sets, resets, or shows autoboot status.  If no arguments
are given the default is to "show ALL".  The show action ignores the
second argument and always displays the autoboot state for all VMs.

=item boot <vm-name>

Boot a virtual machine.

=item console <vm-name>

Connect to the console of a domu.  Must be executed on the hypervisor.

=item delete <vm-name>

Delete a virtual machine.  The virtual machine should be shutdown
before those command is issued.  This DELETES the VM complete and
the --confirm switch is required.

=item example

Print an example configuration file.  The example is the only
documentation for the configuration file.

=item find [<fragment> <fragment> ...]

Find the xen host for a virtual machine.  Any matching fragment will
cause the virtual machine's xen host to be identified.  If no fragment
is supplied all virtual machines will be listed.

=item freedisk

Display size information about the logical volume used for Xen virtual
machines.

=item freemem

Display amount of memory allocated to VMs, the total system memory,
and the free system memory.  The unit of measure for the displays is
megabytes.

=item destroy <vm-name>

Shutdown a virtual machine without waiting for any process to
complete.  Essentially crashes the vm.

=item key <vm-name>

Download the Kerberos keytab for the host using wallet.  The keytab
must exist and will be downloaded into
/etc/xen-tools/keytabs/<vm-name>.keytab.

=item list

Brief listing of currently defined virtual machines.  A more complete
listing can be generating by adding the --verbose switch.

=item listdists

List current available distributions to use to create virtual machines.

=item listdisks <vm-name>

List disks associated with a virtual machine.

=item mount <vm-name>

Mount the disk associated with a VM as /mnt/<vm-name>.  The VM must be
shutdown before the disk is mounted.

=item new <vm-name>

Create a new virtual machine.

=item reboot <vm-name>

Reboot a virtual machine.

=item show

Show the currently executing virtual machines.

=item showrole [role|ALL]

If not argument or ALL is supplied then a list of role files is display.
If an individual role is supplied then the contents of that role are
displayed.

=item shutdown <vm-name>

Shutdown a virtual machine gracefully.

=item umount <vm-name>

Dismount a VM's disk.

=back

=head1 OPTIONS AND ARGUMENTS

=over 4

=item <vm-name>

The host name of the vm.  Can be fully qualified name.  If not
a fully qualified name then the domain from the configuration
file set used.

=item --arch=i386|amd64

The architecture of the VM.  Defaults to amd64.

=item --cpu=<number of CPUs>

The number of virtual CPUs.  The default is 2.

=item --ip=<address>[/<cidr]

The IP address of the virtual host to be created.  In addition to
being an IP addres the address can either 'dhcp' or 'dns'.  If 'dhcp'
is specified then the guest will be configured to use DHCP.  If 'dns'
is specified then the guest will be configured to use a static address
that is retrieved from the DNS.  The IP address is required to be an
valid IP address only if a DNS lookup for the new hostname fails.

=item --debug

Generate debugging messages.

=item --disk=<intUnits>

The size of the disk to create for the virtual machine.  The value
should be an integer followed by the units.  For example 1Gb is 1
gigabyte.  The default is 4 gigabytes.

=item --dist=<dist-name>

Create a virtual machine with dist-name operation system.

=item --diskid=<string>

The diskid of the disk to mount.  Defaults to "-disk".

=item --force

Force destroy when a Xen guest.  This is required when the guest's
configuration file has been deleted, but the guest is still running.

=item --gateway=<ip address>

For VMs with a static address the IP address of the network gateway.
If not specified then the value from the /etc/xen-tools/xen-tools.conf
file is used.

=item --help

A short help message.

=item --manual

The complete documentation.

=item --memory=<intUnits>

The size of memory to use for the virtual machine.  The value should
be an integer followed by the units.  For example: 500Mb is 500
megabytes.  The default is 500 megabytes.

=item --method=<install-method>

Specify the installation method to use. Valid methods are: debootstrap
or rinse.  Default for centos and fedoracore is rinse, debootstrap for
everything else.

=item --moptions=<mount-options>

Options passed to the mount command when mounting a VMs disk.

=item --netmask=<n.n.n.n>

The netmask for VMs with statically assigned IP addresses.  If not
specified then the value from the /etc/xen-tools/xen-tools.conf file
is used.

=item --noudev

Do not include the udev role in the list of roles.

=item --password=<passphrase>

Set the password for the root user of a new virtual machine.  Defaults
to vmPassWord.

=item --pygrub

Generate a Xen configuration file that uses pygrub to boot the new
virtual machine.

=item --role=<comma separated list>

Specifies the xen-tools roles to use when building a host.  The
default is udev,cz-<distname>.

=item --running

When used with the find command restricts search to running xen
guests.

=item --setup=<setup file>

The setup file used to define a "xen cluster".  It allows for the
execution of a selected set of commands to be run on multiple nodes in
the cluster.

=item --swapsize=<size of swapfile>

The size of the swap file.

=item --toolset=[xl|xm]

The tool set to use.  The default is either the setting in the
TOOLSTACK setting in the /etc/default/xen file or 'xm'.

=item --verbose

We applicable display additional information.  Currently only affects
the output of the list command.

=back

=head1 EXAMPLE

Create a Ubuntu bionic virtual machine:

    cz-xen new somehost --disk=10Gb --memory=500Mb --dist=bionic

=head1 AUTHOR

Bill MacAllister <bill@ca-zephyr.org>

=head1 COPYRIGHT

This software was developed for use at Stanford University 2012-2014.
All rights reserved.

Modifications to the software have been made by Bill MacAllister,
2015-2021.  All rights reserved.

=cut
