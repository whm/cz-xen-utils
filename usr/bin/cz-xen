#!/usr/bin/perl
#
# Copyright 2012-2014 Board of Trustees, Leland Stanford Jr. University
# Copyright 2015-2022 Bill MacAllister <bill@ca-zephyr.org>
#
# Script to manage xen virtual hosts

use AppConfig qw(:argcount :expand);
use Carp;
use File::Basename;
use File::Copy;
use Getopt::Long;
use IPC::Open3;
use IPC::Run qw( run timeout );
use Net::DNS;
use Net::Domain qw( hostfqdn );
use Net::Netmask;
use Net::Remctl;
use Pod::Usage;
use CZ::Xentools;
use strict;

my $opt_bridge;
my $opt_confirm;
my $opt_cpu = 2;
my $opt_debug;
my $opt_disk;
my $opt_diskid = '-disk';
my $opt_force;
my $opt_gateway;
my $opt_help;
my $opt_id;
my $opt_ip = 'dhcp';
my $opt_key;
my $opt_manual;
my $opt_mask;
my $opt_memory;
my $opt_moptions;
my $opt_password = 'vmPassWord';
my $opt_running;
my $opt_setup = '/etc/cz-xen-setup.conf';
my $opt_swapsize;
my $opt_verbose;

my $CONF;
my %DIST;
my $DEBUG_TIME = time;

##############################################################################
# Subroutines
##############################################################################

# ----------------------------------------------------------------------
# output debugging information

sub dbg {
    (my $tmp) = @_;
    my $now     = time;
    my $elapsed = $now - $DEBUG_TIME;
    print {*STDOUT} "$now ($elapsed) $tmp \n"
      or croak("Problem writing debugging to STDOUT\n");
    $DEBUG_TIME = $now;
    return;
}

# ----------------------------------------------------------------------
# Validate an ip address

sub validate_ip {
    my ($ip) = @_;
    my $err = 0;
    if ($ip !~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/xms) {
        warn "Invalid IP Address: $ip\n";
        my $err = 1;
    }
    return $err;
}

# ----------------------------------------------------------------------
# Validate a list of ip addresses

sub validate_ip_list {
    my ($ip_csv) = @_;
    my @ip_list = split(/,/xms, $ip_csv);
    my $err_cnt;
    foreach my $ip (@ip_list) {
        $err_cnt += validate_ip($ip);
    }
    if ($err_cnt > 0) {
        pod2usage(-verbose => 0);
    }
    return;
}

# ----------------------------------------------------------------------
# Take an address/cidr and return the corresponding netmask

sub net_size2mask {
    my ($ip_cidr) = @_;
    my $block = Net::Netmask->new($ip_cidr);
    return $block->mask();
}

# ----------------------------------------------------------------------
# Fork a shell command line and send the output to the parent process

sub fork_cmd {
    my ($timeout, @cmd) = @_;

    my $pid;
    my $cmd_line = 'Executing: ' . join(' ', @cmd);
    msg("$cmd_line\n");
    cz_syslog($cmd_line);
    eval {
        alarm $timeout;
        # write to parent STDOUT and STDERR
        $pid = open3(my $chld_in, '>&STDOUT', '>&STDERR', @cmd);
        # retrieve exit status when child finishes
        waitpid($pid, 0);
        my $child_exit_status = $? >> 8;
        alarm 0;
    };
    if ($@) {
        if ($pid) {
            kill 9, $pid;
        }
        my $err .= "ERROR executing:$cmd_line\n";
        $err .= $@;
        croak "$err\n";
    }
    if ($opt_debug) {
        dbg("Command complete: $cmd_line");
    }
    return;
}

# ----------------------------------------------------------------------
# Run a shell command line

sub run_cmd {
    my ($timeout, @cmd) = @_;

    my $in;
    my $out;
    my $err;
    my $cmd_line = 'Executing: ' . join(' ', @cmd);
    msg("$cmd_line\n");
    cz_syslog($cmd_line);
    eval { run(\@cmd, \$in, \$out, \$err, timeout($timeout)); };
    if ($@) {
        if ($err) {
            $err .= "\n";
        }
        $err .= "ERROR executing:$cmd_line\n";
        $err .= $@;
        croak "$err\n";
    }
    if ($opt_debug) {
        if ($out) {
            msg("$out\n");
        }
        if ($err) {
            msg("INFO: $err\n");
        }
    }
    return $out;
}

# ----------------------------------------------------------------------
# Lookup IP address

sub lookup_ip {
    my ($host) = @_;
    my $ip;
    my $res   = Net::DNS::Resolver->new;
    my $query = $res->search($host);
    if ($query) {
        foreach my $rr ($query->answer) {
            if ($rr->type eq 'A') {
                $ip = $rr->address;
                last;
            }
        }
    }
    return $ip;
}

# ----------------------------------------------------------------------
# Validate the xen configuration file

sub validate_xen_conf {
    my ($vhost) = @_;
    my $conf_file = "/etc/xen/${vhost}.cfg";
    if (!-e $conf_file) {
        msg("ERROR: $vhost not a Xen host.\n");
        exit 1;
    }
    return $conf_file;
}

# ----------------------------------------------------------------------
# Read the setup configuration file if it exists

sub read_conf {
    if ($opt_debug) {
        dbg("reading setup file $opt_setup");
    }
    $CONF = AppConfig->new({});
    $CONF->define(
        'command_path',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/bin:/sbin:/usr/bin:/usr/sbin'
        }
    );
    $CONF->define('copy_file', { ARGCOUNT => ARGCOUNT_LIST });
    $CONF->define(
        'default_arch',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 'amd64'
        }
    );
    $CONF->define(
        'default_config',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/etc/xen-tools/xen-tools.conf'
        }
    );
    $CONF->define(
        'default_disk',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '64Gb'
        }
    );
    $CONF->define(
        'default_dist',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 'focal'
        }
    );
    $CONF->define('default_domain', { ARGCOUNT => ARGCOUNT_ONE });
    $CONF->define(
        'default_memory',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '4Gb'
        }
    );
    $CONF->define(
        'default_role',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 'cz-focal'
        }
    );
    $CONF->define(
        'default_template',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/etc/xen-tools/vm.tmpl'
        }
    );
    $CONF->define(
        'keytab_directory',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/etc/xen-tools/keytabs'
        }
    );
    $CONF->define(
        'krb_keytab',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/etc/krb5.keytab'
        }
    );
    $CONF->define(
        'krb_principal',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 'host/' . hostfqdn()
        }
    );
    $CONF->define(
        'krb_realm',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 'DOMAIN.TOP'
        }
    );
    $CONF->define(
        'tgt_file',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/tmp/cz-xen-backup-' . $$ . '.tgt'
        }
    );
    $CONF->define(
        'timeout_action',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '2'
        }
    );
    $CONF->define(
        'timeout_delete',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '5'
        }
    );
    $CONF->define(
        'timeout_list',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '2'
        }
    );
    $CONF->define(
        'timeout_mount',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '2'
        }
    );
    $CONF->define(
        'timeout_new',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '30'
        }
    );
    $CONF->define(
        'use_old_xen_delete_image',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => 0
        }
    );
    $CONF->define(
        'xen_cfg_dir',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/etc/xen'
        }
    );
    $CONF->define(
        'xen_tools_dir',
        {
            ARGCOUNT => ARGCOUNT_ONE,
            DEFAULT  => '/etc/xen-tools'
        }
    );
    $CONF->define('xen_server', { ARGCOUNT => ARGCOUNT_LIST });
    $CONF->define('xt_id',      { ARGCOUNT => ARGCOUNT_LIST });

    # Read the configuration file if there is one
    if (-e $opt_setup) {
        $CONF->file($opt_setup);
    } else {
        die("ERROR: missing configuration file $opt_setup");
    }

    # Parse out configuration by id.  In most cases the id is
    # synomous with distribution, but it does not have to be.
    # The id configuration attributes have the form id/attr/value.
    my %valid_attr = (
        'arch'     => 1,
        'dist'     => 1,
        'config'   => 1,
        'pygrub'   => 1,
        'role'     => 1,
        'setup'    => 1,
        'template' => 1,
    );
    # Parse the id values
    if (!$CONF->xt_id) {
        die("ERROR: Missing id configurations in $opt_setup");
    }
    for my $xt (sort(@{ $CONF->xt_id })) {
        if ($xt =~ /(\S+) \s* \/ \s* (\S+) \s* \/ \s* (.*)/xms) {
            my $id   = $1;
            my $attr = $2;
            my $val  = $3;
            if (!$valid_attr{$attr}) {
                msg("WARN: invalid xt_id '$id'. Skipping: $xt\n");
                next;
            }
            $DIST{$id}{$attr} = $val;
        } else {
            msg("WARN: bad format.  Skipping $xt\n");
        }
    }
    # Set defaults for the id attributes
    for my $id (sort keys %DIST) {
        # set arch
        if (!$DIST{$id}{'arch'}) {
            $DIST{$id}{'arch'} = $CONF->default_arch();
        }
        if ($DIST{$id}{'arch'} !~ /^(?:i386|amd64)$/xms) {
            msg("WARN: invalid arch $DIST{$id}{'arch'}\n");
            msg("INFO: setting arch to amd64\n");
            $DIST{$id}{'arch'} = 'amd64';
        }
        # set xen-tools config
        if (!$DIST{$id}{'config'}) {
            $DIST{$id}{'config'} = $CONF->default_config();
        }
        # set dist
        if (!$DIST{$id}{'dist'}) {
            $DIST{$id}{'dist'} = $CONF->default_dist();
        }
        # set role
        if (!$DIST{$id}{'role'}) {
            $DIST{$id}{'role'} = $CONF->default_role();
        }
        my @role_files = split /,/, $DIST{$opt_id}{'role'};
        for my $f (@role_files) {
            my $role_file = $CONF->xen_tools_dir() . "/role.d/$f";
            if (!-e $role_file) {
                msg("ERROR: $role_file is missing\n");
            }
        }
        # set template
        if (!$DIST{$id}{'template'}) {
            $DIST{$id}{'template'} = $CONF->default_template();
        }
    }

    # Command line overrides
    if ($opt_disk) {
        $CONF->default_disk($opt_disk);
    }
    if ($opt_memory) {
        $CONF->default_memory($opt_memory);
    }

    return;
}

# ----------------------------------------------------------------------
# Display example configuration file

sub example_conf {

    msg("# ----------------------------------------------------\n");
    msg("# Example su xen configuration file $opt_setup\n");
    msg("#\n");
    msg("# ----------------------------------------------------\n");
    msg("#\n");
    msg("# Set the PATH\n");
    msg("command_path = /bin:/sbin:/usr/bin:/usr/sbin\n");
    msg("#\n");
    msg("# Copy files from dom0 to domu.\n");
    msg("# (The script always checks for a host keytab.)\n");
    msg("copy_file = /some/dir/file1 to /some/dir/file1\n");
    msg("copy_file = /other/dir/file2 to /some/dir/file3\n");
    msg("#\n");
    msg("# Default architecture\n");
    msg("default_arch = amd64\n");
    msg("#\n");
    msg("# Default disk size\n");
    msg("default_disk = 64Gb\n");
    msg("#\n");
    msg("# Default xen-tools configuration\n");
    msg("default_config = xen-tools.conf\n");
    msg("#\n");
    msg("# Default distribution\n");
    msg("default_dist = focal\n");
    msg("#\n");
    msg("# Default domain\n");
    msg("default_domain = ca-zephyr.org\n");
    msg("#\n");
    msg("# Default memory allocation\n");
    msg("default_memory = 4Gb\n");
    msg("#\n");
    msg("# Default xen-tools role\n");
    msg("default_role = cz-focal\n");
    msg("#\n");
    msg("# Default xen-tools template for xen cfg generation\n");
    msg("default_template = xm.tmpl\n");
    msg("#\n");
    msg("# Directory that hosts keytabs for virtual machines.\n");
    msg("keytab_directory = /etc/xen-tools/keytabs\n");
    msg("#\n");
    msg("# Kerberos credentials used for requesting services of other\n");
    msg("# other xen servers.\n");
    msg("krb_keytab = /etc/krb5.keytab\n");
    msg("krb_principal = host/thishost.domain.top\n");
    msg("krb_realm = DOMAIN.TOP\n");
    msg("tgt_file = /tmp/cz-xen.tgt\n");
    msg("#\n");
    msg("# The timeout unit of measure is minutes\n");
    msg("timeout_action = 2\n");
    msg("timeout_delete = 5\n");
    msg("timeout_list = 2\n");
    msg("timeout_mount = 2\n");
    msg("timeout_new = 30\n");
    msg("#\n");
    msg("# Use old xen-delete-image syntax.  The syntax changed at 4.14\n");
    msg("# 0 is false, and not zero is true.\n");
    msg("use_old_xen_delete_image = 0\n");
    msg("#\n");
    msg("# Xen configuration directory\n");
    msg("xen_cfg_dir = /etc/xen\n");
    msg("#\n");
    msg("# xen-tools directory\n");
    msg("xen_tools_dir = /etc/xen-tools\n");
    msg("#\n");
    msg("# Servers in the xen pool.  This used by the find command.\n");
    msg("xen_server = server1.domain.top\n");
    msg("xen_server = server2.domain.top\n");
    msg("xen_server = server3.domain.top\n");
    msg("#\n");
    msg("# Define installation identifiers.  These configuration \n");
    msg("# describe the VM build parameters. The parameters have the\n");
    msg("# form id/attr/value.\n");
    msg("xt_id = bionic / arch     / amd64\n");
    msg("xt_id = bionic / config   / xen-tools-pygrub.conf\n");
    msg("xt_id = bionic / dist     / bionic\n");
    msg("xt_id = bionic / pygrub   / 1\n");
    msg("xt_id = bionic / role     / udev,cz-bionic\n");
    msg("xt_id = bionic / template / xm-pygrub.tmpl\n");
    msg("#\n");
    msg("xt_id = focal / config   / xen-tools-pvh.conf\n");
    msg("xt_id = focal / dist     / focal\n");
    msg("xt_id = focal / role     / cz-focal\n");
    msg("xt_id = focal / template / xm-pyh.tmpl\n");
    msg("#\n");

    return;
}

# ----------------------------------------------------------------------
# Take an array contain elements like '/in/path to /out/path' and
# return a hash of the form $hash{'/in/path'} = '/out/path'.

sub get_install_paths {
    my ($paths_ref) = @_;

    my %paths = ();
    for my $ps (@{$paths_ref}) {
        $ps =~ s/\s+to\s+/ /xms;
        $ps =~ s/^\s+//xms;
        $ps =~ s/\s+$//xms;
        $ps =~ s/\s\s+/ /xmsg;
        my ($in, $out) = split /\s/, $ps;
        if (!$out) {
            msg("Skipping copy line: $ps\n");
        } else {
            $paths{$in} = $out;
        }
    }
    return %paths;
}

# ----------------------------------------------------------------------
# Access the console of a domU

sub console {
    my ($vhost) = @_;
    my @cmd = ('xl', 'console', $vhost);
    msg(join(' ', @cmd) . "\n");
    exec @cmd;
    return;
}

# ----------------------------------------------------------------------
# Copy files from the dom0 systm to the VM

sub copy_dom0_files {
    my ($vhost, $file_list_ref) = @_;

    my %file_list      = %{$file_list_ref};
    my $vm_mount_point = mount_vm_disk($vhost);
    $vm_mount_point =~ s{/$}{}xms;

    for my $to (sort keys %file_list) {
        my $from = $vm_mount_point . '/' . $file_list{$to};
        msg("Copying $from to $to\n");
        copy($from, $to)
          or carp("WARN: problem copying $from to $to\n");
    }
    if ($vm_mount_point) {
        umount_vm_disk($vhost);
    }

    return;
}

# ----------------------------------------------------------------------
# Given a VM configuration file parse out the disk entries and return
# them as an array.

sub get_vm_disks {
    my ($vm_conf) = @_;

    # Read in the configuration pulling out the disk entries.
    open(my $vm_conf_fd, '<', $vm_conf)
      or die("ERROR: problem opening $vm_conf\n");
    my @dev_list = ();
    my $disk_line;
    while (<$vm_conf_fd>) {
        chomp;
        my $inline = $_;
        if ($disk_line && $inline =~ s/\].*//xms) {
            $disk_line .= ']';
            last;
        }
        if ($disk_line) {
            $disk_line .= $inline;
        } else {
            if ($inline =~ /(disk\s*=.*)/xms) {
                $disk_line = $1;
            }
        }
    }
    close $vm_conf_fd
      or croak("ERROR: problem closing $vm_conf\n");
    if (!$disk_line) {
        print("no disks found\n");
        exit;
    }

    # Stripe spaces and disk array syntax elements
    my $disk_list = $disk_line;
    $disk_list =~ s/\s+//xmsg;
    $disk_list =~ s/^disk=\[//xms;
    $disk_list =~ s/\]$//xms;

    # Parse the disk specifications
    my @disks = ();
    while ($disk_list) {
        my $quote = substr($disk_list, 0, 1);
        if ($disk_list =~ /^$quote phy: (.*?) $quote (.*)/xms) {
            my $this_disk = $1;
            $disk_list = $2;
            $this_disk =~ s/,.*//xms;
            $disk_list =~ s/^,//xms;
            push @disks, $this_disk;
        } else {
            print("Unable to parse disk list from $vm_conf\n");
            exit 1;
        }
    }

    return @disks;
}

# ----------------------------------------------------------------------
# Create a hash of the physical devices for logical volumes on this
# system.

sub get_lvols_hash {
    my %disk_hash = ();
    my @cmd       = ('lvdisplay');
    my $out       = run_cmd(60, @cmd);
    my @lines     = split(/\n/, $out);
    my $this_disk;
    for my $a (@lines) {
        if ($a =~ /LV\s+ Path\s+ (.*)/xms) {
            $this_disk = $1;
            $disk_hash{$this_disk} = 'UNKNOWN-VOLUME-GROUP';
        }
        if ($a =~ /VG\s+ Name\s+ (.*)/xms) {
            my $this_vol = $1;
            $disk_hash{$this_disk} = $this_vol;
        }
    }
    return %disk_hash;
}

##############################################################################
# Script Actions
##############################################################################

# ----------------------------------------------------------------------
# Maintain auto action for VMs

sub auto_maint {
    my ($action, $this_host) = @_;

    my %cfg_file = ();
    opendir(my $dir, $CONF->xen_cfg_dir())
      or croak('ERROR: problem opening ' . $CONF->xen_cfg_dir() . "\n");
    while (my $file = readdir($dir)) {
        if ($file =~ /[.]cfg$/xms) {
            my $a_host = $file;
            $a_host =~ s/[.]cfg$//xms;
            $cfg_file{ $CONF->xen_cfg_dir() . "/${file}" } = $a_host;
        }
    }
    closedir($dir);

    # Set a default action
    if (!$action) {
        $action    = 'show';
        $this_host = 'ALL';
    }

    # show auto status for all hosts
    if ($action eq 'show') {
        msg("AUTOBOOT Status\n");
        msg("---------------\n");
        for my $f (sort keys %cfg_file) {
            my $h = $cfg_file{$f};
            my $a = $CONF->xen_cfg_dir() . "/auto/${h}.cfg";
            if (-e $a) {
                msg("AUTOBOOT $h\n");
            } else {
                msg("no autoboot link for $h\n");
            }
        }
        return;
    }

    if (!$this_host) {
        msg("ERROR: an fqdn or ALL must be specified\n");
        exit 1;
    }

    # get a list of files to operate on
    my @file_list = ();
    if ($this_host eq 'ALL') {
        for my $f (sort keys %cfg_file) {
            push @file_list, $f;
        }
    } else {
        my $this_file = $CONF->xen_cfg_dir() . "/${this_host}.cfg";
        if (!-e $this_file) {
            msg("ERROR: invalid host ($this_host)\n");
            exit 1;
        } else {
            push @file_list, $this_file;
        }
    }

    # Perform the operation
    for my $f (sort @file_list) {
        my $h              = $cfg_file{$f};
        my $this_auto_file = $CONF->xen_cfg_dir() . "/auto/${h}.cfg";
        if ($action eq 'on') {
            my $a_dir = $CONF->xen_cfg_dir() . '/auto';
            if (!-e $a_dir) {
                mkdir $a_dir, 0755
                  or croak("ERROR: problem creating $a_dir\n");
            }
            if (-e $this_auto_file) {
                msg("INFO: $h already set to AUTOBOOT\n");
            } else {
                msg("Setting $h to AUTOBOOT\n");
                link $f, $this_auto_file
                  or croak("ERROR: problem link to $f\n");
            }
        } elsif ($action eq 'off') {
            if (-e $this_auto_file) {
                unlink $this_auto_file
                  or croak("ERROR: problem removing link $this_auto_file\n");
            } else {
                msg("INFO: $h not set to autoboot\n");
            }
        } else {
            msg("ERROR: invalid action $action\n");
            exit 1;
        }
    }

    return;
}

# ----------------------------------------------------------------------
# Create a virtual machine

sub create_vm {
    my ($vhost) = @_;

    # Require both hostname
    if (!$vhost) {
        warn "Insufficient arguments\n";
        pod2usage(-verbose => 0);
    }

    # Get an ip address
    my $vip = $opt_ip;
    if ($opt_ip eq 'dns') {
        $vip = lookup_ip($vhost);
        if (!$vip) {
            msg("ERROR:IP Address lookup failed, specify address with --ip\n");
            pod2usage(-verbose => 0);
        }
    }

    # Make sure it looks like an ip address
    if ($opt_ip ne 'dhcp') {
        validate_ip($vip);
    }

    # validate size specifications
    my $z;
    if ($CONF->default_disk() !~ /^\d+(?: Gb | Mb )/xmsi) {
        warn "Invalid value for disk size.  Units are Mb or Gb.\n";
        pod2usage(-verbose => 0);
    }
    $z = $CONF->default_disk();
    $z =~ tr/gmB/GMb/;
    $CONF->default_disk($z);
    if ($CONF->default_memory() !~ /^\d+(?: Gb | Mb )/xmsi) {
        warn "Invalid value for memory size.  Units are Mb or Gb.\n";
        pod2usage(-verbose => 0);
    }
    $z = $CONF->default_memory();
    $z =~ tr/gmB/GMb/;
    $CONF->default_memory($z);
    if ($opt_swapsize) {
        if ($opt_swapsize !~ /^\d+(?: Gb | Mb )/xmsi) {
            warn "Invalid value for swap size.  Units are Mb or Gb.\n";
            pod2usage(-verbose => 0);
        }
        $opt_swapsize =~ tr/gmB/GMb/;
    }

    # validate the id
    if (!$DIST{$opt_id}) {
        msg("ERROR: Invalid id $opt_id\n");
        msg('INFO: Valid values are ');
        for my $id (sort keys %DIST) {
            msg("$id ");
        }
        msg("\n");
        msg("FATAL: valid id is required\n");
        exit 1;
    }

    # Get the keytab for the host if requested
    if ($opt_key) {
        get_keytab($vhost);
    }

    # generate the vm
    my $config = $CONF->xen_tools_dir . '/' . $DIST{$opt_id}{'config'};
    if (!-e $config) {
        die("ERROR: missing config file $config");
    }
    my $tmpl = $CONF->xen_tools_dir . '/' . $DIST{$opt_id}{'template'};
    if (!-e $tmpl) {
        die("ERROR: missing template file $tmpl");
    }
    my @cmd = ('/usr/bin/xen-create-image');
    push @cmd, "--hostname=${vhost}";
    push @cmd, '--memory=' . $CONF->default_memory;
    push @cmd, '--genpass=1';
    push @cmd, '--size=' . $CONF->default_disk();
    push @cmd, "--template=$tmpl";
    push @cmd, "--config=$config";

    if ($opt_bridge) {
        push @cmd, "--bridge=$opt_bridge";
    }
    if ($opt_ip eq 'dhcp') {
        push @cmd, "--dhcp";
    } else {
        push @cmd, "--ip=${vip}";
        if ($opt_gateway) {
            push @cmd, "--gateway=$opt_gateway";
        }
        if ($opt_mask) {
            push @cmd, "--mask=$opt_mask";
        }
    }
    if ($opt_cpu) {
        push @cmd, "--vcpus=$opt_cpu";
    }
    if ($DIST{$opt_id}{'pygrub'}) {
        push @cmd, '--pygrub';
    }
    if ($opt_swapsize) {
        push @cmd, "--swap=${opt_swapsize}";
    } else {
        push @cmd, '--noswap';
    }
    push @cmd, "--role=$DIST{$opt_id}{'role'}";
    push @cmd, "--dist=$DIST{$opt_id}{'dist'}";
    push @cmd, "--arch=$DIST{$opt_id}{'arch'}";
    msg("Be patient this takes time ...\n");
    my $create_timeout = 60 * $CONF->timeout_new();
    fork_cmd($create_timeout, @cmd);

    # Look for files to copy from dom0 to domu
    my %file_list   = ();
    my $principal   = "host/$vhost";
    my $keytab_file = $CONF->keytab_directory . '/' . $vhost . '.keytab';
    if (-e $keytab_file) {
        $file_list{'/etc/krb5.keytab'} = $keytab_file;
    }
    for my $copy_request (sort(@{ $CONF->copy_file })) {
        if ($copy_request =~ /(\S+) \s+ to \s+ (\S+)/xms) {
            my $from = $1;
            my $to   = $2;
            $file_list{$to} = $from;
        } else {
            msg("WARN: bad format.  Skipping copy_file = $copy_request\n");
        }
    }
    if (%file_list) {
        copy_dom0_files($vhost, \%file_list);
    }

    return;
}

# ----------------------------------------------------------------------
# Delete a virtual machine

sub delete_vm {
    my ($vhost) = @_;

    if (!$opt_confirm) {
        msg("INFO: The VM be deleted from the disk.\n");
        msg("INFO: This is NOT reversable.\n");
        msg("\n");
        msg("INFO: If you mean to shut the VM down use destroy instead.\n");
        msg("\n");
        msg("INFO: To delete the VM complete add the --confirm switch to \n");
        msg("INFO: the command line.\n");

        die("ERROR: Refusing to delete VM without --confirm\n");
    }

    # Make sure we know what to delete
    my $vm_conf = validate_xen_conf($vhost);

    # set timeout for command execution
    my $cmd_timeout = 60 * $CONF->timeout_delete();

    # destroy it first if it is running
    my @cmd   = ('xl', 'list');
    my $out   = run_cmd($cmd_timeout, @cmd);
    my @lines = split /\n/, $out;
    for my $s (@lines) {
        if ($s =~ /^$vhost\s/xms) {
            @cmd = ('xl', 'destroy', $vhost);
            fork_cmd($cmd_timeout, @cmd);
            last;
        }
    }

    # Use the old syntaxt for xen-delete-image.  This allows older
    # systems to use newer cz-xen versions.
    if ($CONF->use_old_xen_delete_image()) {
        my @cmd = ('/usr/bin/xen-delete-image', ${vhost});
        fork_cmd($cmd_timeout, @cmd);
        if ($@) {
            msg('ERROR: Problem executing:' . join(q{ }, @cmd));
            croak($@);
        }
        return;
    }

    # The new xen-delete-image command supports several disk
    # technologies.  Start with support for lvm.
    my @disks = get_vm_disks($vm_conf);
    my %lvols = get_lvols_hash();
    my $vg;
    for my $disk (@disks) {
        if ($lvols{$disk}) {
            if ($lvols{$disk} eq 'UNKNOWN-VOLUME-GROUP') {
                msg("WARNING: skipping $disk, unknown volume group\n");
                next;
            }
            if (!$vg) {
                $vg = $lvols{$disk};
            } elsif ($vg ne $lvols{$disk}) {
                msg("WARNING: skipping ambigous volume group $lvols{$disk}\n");
                next;
            }
        }
    }
    if ($vg) {
        my @cmd_lvm = ('xen-delete-image', "--lvm=$vg", "--host=$vhost");
        my $out     = run_cmd($cmd_timeout, @cmd_lvm);
        msg("$out\n");
    } else {
        msg("INFO: volume group not found assuming local disk storage\n");
    }

    return;
}

# ----------------------------------------------------------------------
# This is a dispatching routine that calls either the search for a
# running vm or search for any vm routines.

sub find_vm {
    my @regex_list = @_;

    if (!@{ $CONF->xen_server }) {
        die "ERROR: no xen_server's defined in the configuration file\n";
    }

    if ($opt_debug) {
        dbg('Using principal: ' . $CONF->krb_principal);
        dbg('Keytab file ' . $CONF->krb_keytab);
    }
    create_ticket_cache($CONF);
    if ($opt_running) {
        find_running(@regex_list);
    } else {
        find_any_vm(@regex_list);
    }
    destroy_ticket_cache($CONF);

    return;
}

# ----------------------------------------------------------------------
# Find running VMs or display all of them

sub find_running {
    my @regex_list = @_;

    my $cnt = 1;
    my @report;
    msg('Searching ' . scalar(@{ $CONF->xen_server }) . ' hosts: ');
    for my $xhost (sort(@{ $CONF->xen_server })) {
        my $host_found = 0;
        print("$cnt ");
        $cnt++;

        my @cl = ();
        push @cl, 'xen', 'show';
        if ($opt_debug) {
            dbg('Executing: remctl ' . $xhost . ' ' . join(' ', @cl));
        }
        my $remctl = Net::Remctl->new;
        $remctl->set_timeout(30);
        if (!$remctl->open($xhost)) {
            msg("\nERROR: cannot connect to $xhost\n");
            msg("INFO: skipping\n");
            next;
        }
        if (!$remctl->command(@cl)) {
            msg("\nERROR: cannot send command: " . $remctl->error . "\n");
            msg("INFO: skipping\n");
            next;
        }
        my $output;
        my $output_data;
        do {
            $output = $remctl->output;
            if ($output->type eq 'output') {
                if ($output->stream == 1) {
                    $output_data .= $output->data;
                } elsif ($output->stream == 2) {
                    msg("\nERROR: " . $output->data . "\n");
                }
            } elsif ($output->type eq 'error') {
                msg("\nERROR:" . $output->error . "\n");
            } elsif ($output->type eq 'status') {
                if ($opt_debug) {
                    dbg('output status:' . $output->status);
                }
            } else {
                die "Unknown output token from library: ", $output->type, "\n";
            }
        } while ($output->type eq 'output');
        if ($output_data) {
            my @host_list = split "\n", $output_data;
            for my $h (@host_list) {
                if ($h =~ m/^(\S+)\s+(\d+)\s+(\d+)/xms) {
                    my $vhost = $1;
                    my $id    = $2;
                    my $mem   = $3;
                    for my $r (@regex_list) {
                        if ($vhost =~ /$r/xms) {
                            if (!$host_found) {
                                push @report, "$xhost\n";
                                $host_found = 1;
                            }
                            push @report, sprintf("  %4s %s\n", $vhost, $id);
                        }
                    }
                }
            }
        }
    }

    msg("\n");
    if (@report) {
        msg("\n");
        for my $z (@report) {
            msg($z);
        }
    } else {
        msg("INFO: No matching hosts found\n");
    }
    return;
}

# ----------------------------------------------------------------------
# Find any or all VMs

sub find_any_vm {
    my @regex_list = @_;

    my $cnt = 1;
    my @report;
    msg('Searching ' . scalar(@{ $CONF->xen_server }) . ' hosts: ');
    for my $xhost (@{ $CONF->xen_server }) {
        my $host_found = 0;
        print("$cnt ");
        $cnt++;

        my @cl = ();
        push @cl, 'xen', 'list';
        if ($opt_debug) {
            dbg('Executing: remctl ' . $xhost . ' ' . join(' ', @cl));
        }
        my $remctl = Net::Remctl->new;
        $remctl->set_timeout(30);
        if (!$remctl->open($xhost)) {
            msg("\nERROR: cannot connect to $xhost\n");
            msg("INFO: skipping\n");
            next;
        }
        if (!$remctl->command(@cl)) {
            msg("\nERROR: cannot send command: " . $remctl->error . "\n");
            msg("INFO: skipping\n");
            next;
        }
        my $output;
        my $output_data;
        do {
            $output = $remctl->output;
            if ($output->type eq 'output') {
                if ($output->stream == 1) {
                    $output_data .= $output->data;
                } elsif ($output->stream == 2) {
                    msg("\nERROR: " . $output->data . "\n");
                }
            } elsif ($output->type eq 'error') {
                msg("\nERROR: " . $output->error . "\n");
            } elsif ($output->type eq 'status') {
                if ($opt_debug) {
                    dbg('output status:' . $output->status);
                }
            } else {
                die "Unknown output token from library: ", $output->type, "\n";
            }
        } while ($output->type eq 'output');
        if ($output_data) {
            my @host_list = split "\n", $output_data;
            for my $l (@host_list) {
                if ($l =~ /^Name:\s+(\S+)/xms) {
                    my $this_name = $1;
                    for my $r (@regex_list) {
                        if ($this_name =~ /$r/xms) {
                            if (!$host_found) {
                                push @report, "$xhost\n";
                                $host_found = 1;
                            }
                            push @report, "    $this_name\n";
                        }
                    }
                }
            }
        }
    }

    msg("\n");
    if (@report) {
        msg("\n");
        for my $z (@report) {
            msg($z);
        }
    } else {
        msg("INFO: No matching hosts found\n");
    }
    return;
}

# ----------------------------------------------------------------------
# Download the host keytab

sub get_keytab {
    my ($vhost) = @_;

    if (!$vhost) {
        die "ERROR: name of virtual host missing\n";
    }

    if ($opt_debug) {
        dbg('Using principal: ' . $CONF->krb_principal);
        dbg('Keytab file ' . $CONF->krb_keytab);
    }
    create_ticket_cache($CONF);

    my @cl          = ();
    my $principal   = "host/$vhost";
    my $keytab_file = $CONF->keytab_directory . '/' . $vhost . '.keytab';

    my @cl = ('wallet', 'get', '-f', $keytab_file, 'keytab', $principal);
    if ($opt_debug) {
        dbg('Executing: ' . join(' ', @cl));
    }
    fork_cmd(60, @cl);

    destroy_ticket_cache($CONF);

    return;
}

# ----------------------------------------------------------------------
# List current installation options

sub list_ids {
    # List ids defined in the setup file
    msg("Installable ids:\n");
    for my $id (sort keys %DIST) {
        msg("  $id\n");
        if ($opt_verbose) {
            for my $attr (sort keys %{ $DIST{$id} }) {
                msg("    $attr = $DIST{$id}{$attr}\n");
            }
        }
    }
    return;
}

# ----------------------------------------------------------------------
# List LVM volume group sizes

sub list_freedisk_space {

    my @cmd         = ('/sbin/vgdisplay');
    my $cmd_timeout = 60 * $CONF->timeout_list();
    fork_cmd($cmd_timeout, @cmd);
    return;
}

# ----------------------------------------------------------------------
# Display free memory using xl

sub list_freemem {

    my @cmd         = ('/usr/sbin/xl', 'info');
    my $cmd_timeout = 60 * $CONF->timeout_list();
    fork_cmd($cmd_timeout, @cmd);
    msg("Memory units are megabytes.\n");
    return;
}

# ----------------------------------------------------------------------
# List dom0 information

sub list_info {

    my @cmd         = ('/usr/sbin/xl', 'info');
    my $cmd_timeout = 60 * $CONF->timeout_list();
    fork_cmd($cmd_timeout, @cmd);
    return;
}

# ----------------------------------------------------------------------
# List the disks associated with a VM

sub list_vm_disks {
    my ($vhost) = @_;

    # Require both hostname
    if (!$vhost) {
        msg("WARN: Insufficient arguments\n");
        pod2usage(-verbose => 0);
    }

    # Open the configuration and read until we find the device
    # name for the xen disk.
    my $ch;
    my $vm_conf = validate_xen_conf($vhost);
    open($ch, '<', $vm_conf);
    my $vm_device;
    my $disk_block = 0;
    my $disk_found = 0;
    msg("Disk list for $vhost:\n");

    while (<$ch>) {
        my $in_line = $_;
        if (!$disk_block) {
            if ($in_line =~ /^disk\s+=\s+\[/xms) {
                $disk_block = 1;
            }
            next;
        }
        if ($in_line =~ /\]/xms) {
            last;
        }
        if ($in_line =~ m{\s*phy:(/dev/[\w\d\-\_]+/)([\w\d\-\.]+),}xms) {
            $disk_found = 1;
            my $vm_device      = $1;
            my $vm_disk        = $2;
            my $vm_mount_point = "/mnt/$vm_disk";
            if (-e $vm_mount_point) {
                msg("  vm_disk  MOUNTED\n");
            } else {
                msg("  $vm_disk\n");
            }
        }
    }
    if (!$disk_found) {
        msg("No Disks found\n");
    }
    return;
}

# ----------------------------------------------------------------------
# List virtual machines

sub list_vms {
    my @cmd         = ('/usr/bin/xen-list-images');
    my $cmd_timeout = 60 * $CONF->timeout_list();
    my $out         = run_cmd($cmd_timeout, @cmd);
    if ($opt_verbose) {
        msg($out);
    } else {
        my @lines = split '\n', $out;
        for my $l (@lines) {
            if ($l =~ /^Name:\s+ (.*)/xms) {
                msg("$l\n");
            }
        }
    }
    return;
}

# ----------------------------------------------------------------------
# Manage snapshots, i.e. list them or delete them

sub manage_snapshots {
    my ($action, $frag) = @_;
    my %lvols       = get_lvols_hash();
    my $cnt         = 0;
    my $cmd_timeout = 60 * $CONF->timeout_delete();
    for my $disk (sort keys %lvols) {
        if ($disk =~ /snapshot$/xms) {
            my $this_disk;
            if ($frag) {
                if ($disk =~ /$frag/) {
                    $this_disk = $disk;
                }
            } else {
                $this_disk = $disk;
            }
            if ($this_disk) {
                $cnt++;
                if ($action eq 'delete') {
                    my @cmd_lvm = ('lvremove', '-y', $this_disk);
                    my $out     = run_cmd($cmd_timeout, @cmd_lvm);
                    msg("$out\n");
                } else {
                    msg("$this_disk\n");
                }
            }
        }
    }
    if ($cnt == 0) {
        msg("No snapshots found.\n");
    } else {
        msg("$cnt snapshots found.\n");
    }
    return;
}

# ----------------------------------------------------------------------
# Mount the vm's disk

sub mount_vm_disk {
    my ($vhost) = @_;

    # Require both hostname
    if (!$vhost) {
        msg("WARN: Insufficient arguments\n");
        pod2usage(-verbose => 0);
    }

    # Open the configuration and read until we find the device
    # name for the xen disk.
    my $ch;
    my $vm_conf = validate_xen_conf($vhost);
    open($ch, '<', $vm_conf);
    my $vm_device;
    my $disk_block = 0;
    my $disk_name  = $vhost . $opt_diskid;
    while (<$ch>) {
        my $in_line = $_;
        if (!$disk_block) {
            if ($in_line =~ /^disk\s+=\s+\[/xms) {
                $disk_block = 1;
            }
            next;
        }
        if ($in_line =~ /\]/xms) {
            last;
        }
        if ($in_line =~ m{\s*phy:(/dev/[\w\d\_\-]+/$disk_name),}xms) {
            $vm_device = $1;
            last;
        }
    }
    if (!$vm_device) {
        msg("ERROR: disk $vm_device not found in $vm_conf\n");
        exit 1;
    }
    if (!-e $vm_device) {
        msg("ERROR: disk device $vm_device does not exist\n");
        exit 1;
    }

    # Create the mount point
    my $vm_mount_point = "/mnt/$disk_name";
    if (!-e $vm_mount_point) {
        mkdir $vm_mount_point;
    }

    # Mount the disk
    my @cmd;
    push @cmd, 'mount', $vm_device, $vm_mount_point;
    if ($opt_moptions) {
        push @cmd, '-o', $opt_moptions;
    }
    my $cmd_timeout = 60 * $CONF->timeout_mount();
    fork_cmd($cmd_timeout, @cmd);

    return $vm_mount_point;
}

# ----------------------------------------------------------------------
# Dismount the vm's disk

sub umount_vm_disk {
    my ($vhost) = @_;

    # Require both hostname
    if (!$vhost) {
        msg("WARN: Insufficient arguments\n");
        pod2usage(-verbose => 0);
    }

    # The mount point
    my $vm_mount_point = "/mnt/${vhost}${opt_diskid}";
    if (!-e $vm_mount_point) {
        msg("ERROR: $vm_mount_point not mounted\n");
        exit 1;
    }

    # Dismount the disk
    my @cmd            = ('umount', $vm_mount_point);
    my $umount_timeout = 60 * $CONF->timeout_mount();
    fork_cmd($umount_timeout, @cmd);
    rmdir($vm_mount_point)
      or croak("ERROR: problem deleting mount point $vm_mount_point\n");

    return;
}

# ----------------------------------------------------------------------
# Perform an xm action
sub xtool_action {
    my ($action) = @_;

    my @cmd         = ('xl', $action);
    my $cmd_timeout = 60 * $CONF->timeout_action;
    fork_cmd($cmd_timeout, @cmd);
    return;
}

# ----------------------------------------------------------------------
sub xtool_host_action {
    my ($vhost, $action) = @_;

    # Require hostname
    if (!$vhost) {
        warn "Hostname required\n";
        pod2usage(-verbose => 0);
    }

    # All destroys need to be forced when the configuration file is
    # missing.
    if ($opt_force && $action eq 'destroy') {
        msg("INFO: Force destroy'ing $vhost");
    } else {
        validate_xen_conf($vhost);
    }

    # Perform the requested action
    my @cmd         = ('xl', $action, $vhost);
    my $cmd_timeout = 60 * $CONF->timeout_action();
    fork_cmd($cmd_timeout, @cmd);
    return;
}

# ----------------------------------------------------------------------
sub xtool_conf_action {
    my ($vhost, $action) = @_;
    # Require hostname
    if (!$vhost) {
        warn "Hostname required\n";
        pod2usage(-verbose => 0);
    }
    my $conf_file = validate_xen_conf($vhost);

    my @cmd         = ('xl', 'create', $conf_file);
    my $cmd_timeout = 60 * $CONF->timeout_action();
    fork_cmd($cmd_timeout, @cmd);
    return;
}

##############################################################################
# Main Routine
##############################################################################

GetOptions(
    'bridge=s'   => \$opt_bridge,
    'confirm'    => \$opt_confirm,
    'cpu=i'      => \$opt_cpu,
    'debug'      => \$opt_debug,
    'disk=s'     => \$opt_disk,
    'diskid=s'   => \$opt_diskid,
    'force'      => \$opt_force,
    'gateway=s'  => \$opt_gateway,
    'help'       => \$opt_help,
    'id=s'       => \$opt_id,
    'ip=s'       => \$opt_ip,
    'key!'       => \$opt_key,
    'manual'     => \$opt_manual,
    'mask=s'     => \$opt_mask,
    'memory=s'   => \$opt_memory,
    'moptions=s' => \$opt_moptions,
    'password=s' => \$opt_password,
    'running'    => \$opt_running,
    'setup=s'    => \$opt_setup,
    'swapsize=s' => \$opt_swapsize,
    'verbose'    => \$opt_verbose
) or die("ERROR: invalid command line arguments\n");

# Flush output immediately
$| = 1;

# help the poor souls out
pod2usage(-verbose => 0) if $opt_help;
pod2usage(-verbose => 2) if $opt_manual;
pod2usage(-verbose => 0) if !$ARGV[0] || $ARGV[0] eq 'help';
pod2usage(-verbose => 2) if $ARGV[0] eq 'manual';

my $action = $ARGV[0];

if ($action eq 'example') {
    example_conf();
    exit;
}

# read the configuration file and setup syslog
read_conf();
cz_init_tools(basename($0), $opt_debug);

# Defaults for networking setup if static address
if ($opt_ip ne 'dhcp') {
    if ($opt_gateway) {
        validate_ip($opt_gateway);
    }
    if ($opt_ip =~ /([\d\.]+)\/(\d)+/xms) {
        my $ip   = $1;
        my $cidr = $2;
        $opt_ip   = $ip;
        $opt_mask = net_size2mask("$ip/$cidr");
    }
    if ($opt_mask) {
        validate_ip($opt_mask);
    }
    if ($opt_ip ne 'dns') {
        validate_ip($opt_ip);
    }
}

my $vhost;
my $auto;
my $auto_host;

if ($ARGV[1]) {
    if ($action eq 'auto') {
        if (scalar(@ARGV) > 3) {
            warn("Too many arguments on the command line\n");
            exit(1);
        }
        $auto      = $ARGV[1];
        $auto_host = $ARGV[2];
    } else {
        $vhost = $ARGV[1];
        if ($action ne 'find' && scalar(@ARGV) > 2) {
            warn("Too many arguments on the command line\n");
            exit(1);
        }
    }
}

# Set a default domain if we need to
if ($vhost && $vhost !~ /[.]/xms) {
    if ($CONF->default_domain()) {
        $vhost .= $CONF->default_domain;
    } else {
        warn("Please specify an FQDN for the vhost\n");
        exit(1);
    }
}

# Set the environment so and scripts that are called have the
# correct environment
$ENV{PATH} = $CONF->command_path();

# Do something
if    ($action eq 'auto')      { auto_maint($auto, $auto_host); }
elsif ($action eq 'boot')      { xtool_conf_action($vhost, 'create'); }
elsif ($action eq 'console')   { console($vhost); }
elsif ($action eq 'delete')    { delete_vm($vhost); }
elsif ($action eq 'destroy')   { xtool_host_action($vhost, $action); }
elsif ($action eq 'find')      { find_vm(@ARGV); }
elsif ($action eq 'freedisk')  { list_freedisk_space(); }
elsif ($action eq 'freemem')   { list_freemem(); }
elsif ($action eq 'info')      { list_info(); }
elsif ($action eq 'key')       { get_keytab($vhost); }
elsif ($action eq 'list')      { list_vms(); }
elsif ($action eq 'listdisks') { list_vm_disks($vhost); }
elsif ($action eq 'listids')   { list_ids(); }
elsif ($action eq 'mount')     { mount_vm_disk($vhost); }
elsif ($action eq 'new')       { create_vm($vhost); }
elsif ($action eq 'reboot')    { xtool_host_action($vhost, $action); }
elsif ($action eq 'rmsnaps')   { manage_snapshots('delete', $vhost); }
elsif ($action eq 'show')      { xtool_action('list'); }
elsif ($action eq 'shutdown')  { xtool_host_action($vhost, $action); }
elsif ($action eq 'snaps')     { manage_snapshots('', $vhost); }
elsif ($action eq 'umount')    { umount_vm_disk($vhost); }
else {
    warn "Unknown action ($action)\n";
    pod2usage(-verbose => 0);
}

exit;

__END__

=head1 NAME

cz-xen - Manage Xen Virtual Machines

=head1 SYNOPSIS

     cz-xen auto [on|off|show] [<vm-name>|ALL]
     cz-xen boot <vm-name>
     cz-xen console <vm-name>
     cz-xen delete <vm-name>
     cz-xen destroy <vm-name> [--force]
     cz-xen example
     cz-xen find [<fragment> <fragment> ...]
     cz-xen freedisk
     cz-xen freemem
     cz-xen help
     cz-xen list
     cz-xen listdisks <vm-name>
     cz-xen listids
     cz-xen key <vm-name>
     cz-xen manual
     cz-xen mount <vm-name> [<mount-options>]
     cz-xen new <vm-name>
     cz-xen reboot <vm-name>
     cz-xen rmsnaps [<fragment>]
     cz-xen show
     cz-xen shutdown <vm-name>
     cz-xen snaps [<fragment>]
     cz-xen umount <vm-name>

=head1 DESCRIPTION

With this script Xen virtual machines (VMs) can be created, booted, shutdown,
and deleted.  Additionally this script can be used to set autoboots
for selected or all hosted virtual machines.

The system relies on xen-tools for define the configuration for
virtual systems.  There are three files that control the creation of
machaines:

=over 4

=item xen-tools configuration files

The configuration file control how VMs are built.  After the base
configuration is read then the configuration file that is defined in
the cz-xen-setup.conf file is read.

=item xen-tools template files

The templates which controls how the xen configuation file is built.

=item xen-tools role files

The configures new VMs.

=back

The default configuration file for this script is
/etc/cz-xen-setup.conf.  For detail description of the setup file see
the "example" action.

=head1 ACTIONS

=over 4

=item auto [show|on|off] [<vm name>|ALL]

The auto action sets, resets, or shows autoboot status.  If no arguments
are given the default is to "show ALL".  The show action ignores the
second argument and always displays the autoboot state for all VMs.

=item boot <vm-name>

Boot a virtual machine.

=item console <vm-name>

Connect to the console of a domu.  Must be executed on the hypervisor.

=item delete <vm-name>

Delete a virtual machine.  The virtual machine should be shutdown
before those command is issued.  This DELETES the VM complete and
the --confirm switch is required.

=item example

Print an example configuration file.  The example is the only
documentation for the configuration file.

=item find [<fragment> <fragment> ...]

Find the xen host for a virtual machine.  Any matching fragment will
cause the virtual machine's xen host to be identified.  If no fragment
is supplied all virtual machines will be listed.

=item freedisk

Display size information about the logical volume used for Xen virtual
machines.

=item freemem

Display amount of memory allocated to VMs, the total system memory,
and the free system memory.  The unit of measure for the displays is
megabytes.

=item destroy <vm-name>

Shutdown a virtual machine without waiting for any process to
complete.  Essentially crashes the vm.

=item key <vm-name>

Download the Kerberos keytab for the host using wallet.  The keytab
must exist and will be downloaded into
/etc/xen-tools/keytabs/<vm-name>.keytab.

=item list

Brief listing of currently defined virtual machines.  A more complete
listing can be generating by adding the --verbose switch.

=item listdisks <vm-name>

List disks associated with a virtual machine.

=item listids

List the configured VM creation options.

=item mount <vm-name>

Mount the disk associated with a VM as /mnt/<vm-name>.  The VM must be
shutdown before the disk is mounted.

=item new <vm-name>

Create a new virtual machine.

=item reboot <vm-name>

Reboot a virtual machine.

=item rmsnaps [<fragment>]

Remove LVM snapshots.  If a <fragment> is not specified then all 
snaps are removed.

=item show

Show the currently executing virtual machines.

=item shutdown <vm-name>

Shutdown a virtual machine gracefully.

=item snaps [<fragment>]

Display LVM snapshots.  If a <fragment> is not specified then all 
snaps are displayed.

=item umount <vm-name>

Dismount a VM's disk.

=back

=head1 OPTIONS AND ARGUMENTS

=over 4

=item <vm-name>

The host name of the vm.  Can be fully qualified name.  If not
a fully qualified name then the domain from the configuration
file set used.

=item --bridge=<bridge identifier>

The network bridge identifier for Xen hosts that have trunked networks.

=item --cpu=<number of CPUs>

The number of virtual CPUs.  The default is 2.

=item --ip=<address>[/<cidr]

The IP address of the virtual host to be created.  In addition to
being an IP addres the address can either 'dhcp' or 'dns'.  If 'dhcp'
is specified then the guest will be configured to use DHCP.  If 'dns'
is specified then the guest will be configured to use a static address
that is retrieved from the DNS.  The IP address is required to be an
valid IP address only if a DNS lookup for the new hostname fails.

=item --debug

Generate debugging messages.

=item --disk=<intUnits>

The size of the disk to create for the virtual machine.  The value
should be an integer followed by the units.  For example 1Gb is 1
gigabyte.  The default is 4 gigabytes.

=item --id=<string>

Create a virtual machine with us the configuration identified by
<string>.  Most commonly this is the distribution, e.g. 'focal',
but it does not have to be.

=item --diskid=<string>

The diskid of the disk to mount.  Defaults to "-disk".

=item --force

Force destroy a Xen guest.  This is required when the guest's
configuration file has been deleted, but the guest is still running.

=item --gateway=<ip address>

For VMs with a static address the IP address of the network gateway.
If not specified then the value from the /etc/xen-tools/xen-tools.conf
file is used.

=item --help

A short help message.

=item --manual

The complete documentation.

=item --memory=<intUnits>

The size of memory to use for the virtual machine.  The value should
be an integer followed by the units.  For example: 500Mb is 500
megabytes.  The default is 500 megabytes.

=item --method=<install-method>

Specify the installation method to use. Valid methods are: debootstrap
or rinse.  Default for centos and fedoracore is rinse, debootstrap for
everything else.

=item --moptions=<mount-options>

Options passed to the mount command when mounting a VMs disk.

=item --netmask=<n.n.n.n>

The netmask for VMs with statically assigned IP addresses.  If not
specified then the value from the /etc/xen-tools/xen-tools.conf file
is used.

=item --password=<passphrase>

Set the password for the root user of a new virtual machine.  Defaults
to vmPassWord.

=item --running

When used with the find command restricts search to running xen
guests.

=item --setup=<setup file>

The setup file used to define a "xen cluster".  It allows for the
execution of a selected set of commands to be run on multiple nodes in
the cluster.

=item --swapsize=<size of swapfile>

The size of the swap file.

=item --verbose

We applicable display additional information.  Currently only affects
the output of the list command.

=back

=head1 EXAMPLE

Create a Ubuntu bionic virtual machine:

    cz-xen new somehost --disk=10Gb --memory=500Mb --id=focal

=head1 AUTHOR

Bill MacAllister <bill@ca-zephyr.org>

=head1 COPYRIGHT

License: Perl

This software was developed for use at Stanford University 2012-2014.
All rights reserved.

Modifications to the software have been made by Bill MacAllister,
2015-2022.  All rights reserved.

=cut
